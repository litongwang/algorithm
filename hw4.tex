\documentclass[12pt,letterpaper]{article}
\usepackage{amsmath, amssymb,algorithmic}
\usepackage[]{algorithm2e}
\usepackage{fullpage}
\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\pagestyle{empty}
\def\pp{\par\noindent}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\renewcommand{\baselinestretch}{1.2}
\newcommand{\problem}[1]{ \bigskip \pp \textbf{Problem #1}\par}
\newcommand{\solution}{\textit{Solution:}\par}
\newcommand{\answer}{\medskip\pp\textit{Answer:} }
\newcommand{\lemma}[1]{\medskip\pp\textit{Lemma #1:}}
\newcommand{\proof}{\medskip\pp\textit{Proof:} }
\newcommand{\hint}[1] {\par{\footnotesize {\bf Hint:} #1}}
\newcommand{\remark}[1]{\par{\footnotesize {\bf Remark:} #1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\bbZ}    {\mathbb{Z}}
\newcommand{\bbQ}    {\mathbb{Q}}
\newcommand{\bbN}    {\mathbb{N}}
\newcommand{\bbB}    {\mathbb{B}}
\newcommand{\bbR}    {\mathbb{R}}
\newcommand{\bbC}    {\mathbb{C}}
\newcommand{\calP}   {{\cal{P}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\DeclareMathOperator{\E}{E}
\DeclareMathOperator{\Var}{Var}
\DeclareMathOperator{\cov}{cov}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\centerline{\bf EECS 336}

\medskip
\centerline{Litong Wang}
\centerline{Homework 4}
\centerline{May 4, 2016}
\bigskip


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\problem{1}
\solution
I think the greedy algorithm discussed in the paper is incorrect. The algorithm proposed in the paper always picks the symbol that comes earlier in string Y. \\
The paper claims that it leaves as much opportunity as possilble for the remaining symbols to be select. However, we can easily find counter example to prove it wrong. For example, consider these two input array: \\
$$X = [A,B,B,B]$$
$$Y = [B,A,B,B]$$
In the first iteration, accoding to the algorithm presented in the paper. We need to discard $A$ in $X$, then the result of this algorithm for the longest common subsequence will be $BB$. However, we can easily note that the correct result should be $ABB$.

\problem{2}
\solution
Let $C_1(T)$ to be the cost function mentioned in class and $C_2(T)$ to be the cost function presented in textbook. \\
$$C_1(T) = \sum_{i=1}^{n} P_i \times level(a_i) + \sum_{i=0}^{n} Q_i \times (level(e_i)-1) $$
$$C_2(T) = \sum_{i=1}^{n} P_i \times level(a_i) + \sum_{i=0}^{n} Q_i \times level(e_i) $$
We can easily see that \\ 
$$C_2(T) - C_1(T) = \sum_{ n = i }^{j} Q_n$$
During the construction of the optimal binary tree, we will use the following formula: \\
$$C(i,j) = \min_{i \le n \le j} \lbrace C(i,k-1) + C(k+1,j) + \sum_{m = i}^{j} P_m + \sum_{m = i - 1}^{j} Q_m \rbrace$$
Assume we find the optimal solution $k' \in [i,j] $ by using $C_2(T)$, then we can say that for any $k \in [i,j]$: \\
$$C_2(i,k-1) + C_2(k+1,j) \le C_2(i,k'-1) + C_2(k'+1,j)$$
$$\Leftrightarrow$$
$$C_1(i,k-1) + \sum_{ n = i }^{k-1} Q_n + C_1(k+1,j) + \sum_{ n = k+1 }^{j} Q_n \le C_1(i,k'-1) + \sum_{ n = i }^{k'-1} Q_n + C_1(k'+1,j) + \sum_{ n = k'+1 }^{j} Q_n$$
$$\Leftrightarrow$$
$$C_1(i,k-1) + C_1(k+1,j) \le C_1(i,k'-1) + C_1(k'+1,j)$$
We can see that we will choose the same $k'$ to be our optimal solution using $C_1(T)$. Hence, these two cost model will produce the same optimal binary tree.

\problem{3}
The Shortest Maximum-Weight Common Subsequence Problem: \\
\solution
Table: \\
$\bullet \quad W[i,j]$ = the maximum-weight of a common subsequence of the prefix $x_1,x_2,\cdots,x_i$ and $y_1,y_2,\cdots,y_j$ \\
$\bullet \quad L[i,j]$ = the shortest length of a maximum-weight common subsequence of the prefix $x_1,x_2,\cdots,x_i$ and $y_1,y_2,\cdots,y_j$ \\
$ 0 \le i \le m $ \\
$ 0 \le j \le n $ \\
Output for the problem: \\
The shortest maximum-weight of a common subsequence. \\
Base Case: \\
$\bullet \quad i = 0, W[i,j] = 0, L[i,j] = 0$ \\
$\bullet \quad j = 0, W[i,j] = 0, L[i,j] = 0$ \\
Recursion Case: \\
$\bullet \quad 1 \le i \le m\  and\ 1 \le j \le n$ \\
$\bullet \quad $ If $x_i = y_j $ then $ W[i,j] = weight(x_i) + W[i-1,j-1] , L[i,j] = L[i-1,j-1] + 1$ \\
$\bullet \quad $ If $x_i \neq y_j $ , $W[i-1,j] > W[i,j-1] $ then $W[i,j] = W[i-1,j], L[i,j] = L[i-1,j]$ \\
$\bullet \quad $ If $x_i \neq y_j $ , $W[i,j-1] > W[i-1,j] $ then $W[i,j] = W[i,j-1], L[i,j] = L[i,j-1]$ \\
$\bullet \quad $ If $x_i \neq y_j $ , $W[i,j-1] = W[i-1,j] $ then $W[i,j] = W[i,j-1] = W[i-1,j], L[i,j] = \min \{ L[i,j-1], L[i-1,j] \}$ \\
Correctness: \\
Table $W[i,j]$ represent the maximum weight of the common subsequence of prefix $x_1,x_2,\cdots,x_i$ and $y_1,y_2,\cdots,y_j$. If the $x_i = y_j$, then we must append $x_i$ to the result common subsequence $S$. If we don't append $x_i$, and we get a result $S'$. We must can find a common subsequence $S$ with weight is larger than weight of $S'$. In case of $x_i \neq y_j$, we should let $W[i,j] = \max \{ W[i,j-1], W[i-1,j] \}$. If we don't choose the maximum weight, then we cannot meet the goal finding the "maximum" weight. If $x_i \neq y_j \ \&\  W[i,j-1] = W[i-1,j]$, In order to find the shortest maximum weight common subsequence, we need to take the length of the result into consideration. In order to achieve the result with mimimum length, clealy we should choose $L[i,j] = \min \{ L[i,j-1], L[i-1,j] \}$. \\
Space complexity: \\
$\bullet \quad$ The table $W[i,j]$ has $m \times n$ entries, so the space complexity is $\mathcal{O}(mn)$ \\
$\bullet \quad$ The table $L[i,j]$ has $m \times n$ entries, so the space complexity is $\mathcal{O}(mn)$ \\
Time complexity: \\
$\bullet \quad$ The runtime of computing each entry of $W[i,j]$ and $L[i,j]$ is $\mathcal{O}(1)$ \\
$\bullet \quad$ The total runtime of this algorithm is $\mathcal{O}(mn)$ \\

The Minimum-Weight Longest Common Subsequence Problem: \\
\solution
Table: \\
$\bullet \quad W[i,j]$ = the minimum-weight of a common subsequence of the prefix $x_1,x_2,\cdots,x_i$ and $y_1,y_2,\cdots,y_j$ \\
$\bullet \quad L[i,j]$ = the longest length of a maximum-weight common subsequence of the prefix $x_1,x_2,\cdots,x_i$ and $y_1,y_2,\cdots,y_j$ \\
$ 0 \le i \le m $ \\
$ 0 \le j \le n $ \\
Output for the problem: \\
The longest common subsequence with minimum-weight \\
Base Case: \\
$\bullet \quad i = 0, W[i,j] = 0, L[i,j] = 0$ \\
$\bullet \quad j = 0, W[i,j] = 0, L[i,j] = 0$ \\
Recursion Case: \\
$\bullet \quad 1 \le i \le m\  and\ 1 \le j \le n$ \\
$\bullet \quad $ If $x_i = y_j $ then $ L[i,j] = L[i-1,j-1] + 1 , W[i,j] = W[i-1,j-1] + weight(x_i)$ \\
$\bullet \quad $ If $x_i \neq y_j $ , $L[i-1,j] > L[i,j-1] $ then $L[i,j] = L[i-1,j], W[i,j] = W[i-1,j]$ \\
$\bullet \quad $ If $x_i \neq y_j $ , $L[i,j-1] > L[i-1,j] $ then $L[i,j] = L[i,j-1], W[i,j] = W[i,j-1]$ \\
$\bullet \quad $ If $x_i \neq y_j $ , $L[i,j-1] = L[i-1,j] $ then $L[i,j] = L[i,j-1] = L[i-1,j], W[i,j] = \min \{ W[i,j-1], W[i-1,j] \}$ \\
Correctness: \\
Table $L[i,j]$ represent the maximum length of the common subsequence of prefix $x_1,x_2,\cdots,x_i$ and $y_1,y_2,\cdots,y_j$. If the $x_i = y_j$, then we must append $x_i$ to the result common subsequence $S$. If we don't append $x_i$, and we get a result $S'$. We must can find a common subsequence $S$ with length is larger than length of $S'$. In case of $x_i \neq y_j$, we should let $L[i,j] = \max \{ L[i,j-1], L[i-1,j] \}$. If we don't choose the maximum length, then we cannot meet the goal finding the "maximum" length. If $x_i \neq y_j \ \&\  L[i,j-1] = L[i-1,j]$, In order to find the longest minimum weight common subsequence, we need to take the weight of the result into consideration. In order to achieve the result with mimimum length, clealy we should choose $W[i,j] = \min \{ W[i,j-1], W[i-1,j] \}$. \\
Space complexity: \\
$\bullet \quad$ The table $W[i,j]$ has $m \times n$ entries, so the space complexity is $\mathcal{O}(mn)$ \\
$\bullet \quad$ The table $L[i,j]$ has $m \times n$ entries, so the space complexity is $\mathcal{O}(mn)$ \\
Time complexity: \\
$\bullet \quad$ The runtime of computing each entry of $W[i,j]$ and $L[i,j]$ is $\mathcal{O}(1)$ \\
$\bullet \quad$ The total runtime of this algorithm is $\mathcal{O}(mn)$ \\


\problem{4}
\solution
Table: \\
$\bullet \quad Total[i]$ = the minimum total cost for traveling from post 1 to post i. \\
$\bullet \quad 1 \le i \le n$ \\
Output for the problem: \\
$\bullet \quad Total[n]$ \\
Base Case: \\
$\bullet \quad i = 1 $. Then $Total[i] = 0 $  \\
$\bullet \quad i = 2 $ Then $Total[i] = fee[1,2]$ \\
Recursion Case: \\
$\bullet \quad i < j - 1$ \\
$\bullet \quad Total[i] = Total[k] + fee[k,i]$ minimized over $ k = 2,\cdots,i-1$ \\
Algorithm: \\
\begin{algorithm}[H]
\KwData{$1,n,fee[i,j]$}
\KwResult{The minimum total cost}
\If{$n=2$} {
	$return\  A[2] = fee[1,2]$ \;
}
$A[1] = 0$\;
$ i = 2 $\;
\While{ $ i \le n $ }
{
 \While{ $ j < i $} {
 $min = \min \{min,A[j] + fee[j,i] \}$\;
 }
$A[i] = min $\;
$ i ++ $\;
}
   $return\  A[n]$ \;
\end{algorithm}
Correctness: \\
The recurrence in this algorithm can be justified by considering an optimal sequence of renting at some post $ n > 1$. This sequence must contain a last rental from some other post $i$ to post $n$. The cost of this optimal sequence must be the cost of the optimal sequence ends at post $i$, plus the cost of renting from $i$ to $n$. Since all cases for this last rental are considered, the recurrence correctly computes the costs of optimal rental sequence. \\
Space complexity: \\
$\bullet \quad$ Because we have $ n $ entries, so the space complexity is $\mathcal{O}(n)$ \\
Time complexity: \\
$\bullet \quad$ The runtime of computing each entry is $\mathcal{O}(n)$ \\
$\bullet \quad$ The total runtime of this algorithm is $\mathcal{O}(n^2)$ \\

\problem{5}
\solution

\end{document}
